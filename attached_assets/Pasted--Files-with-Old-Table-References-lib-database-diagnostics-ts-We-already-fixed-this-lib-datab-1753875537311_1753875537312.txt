üìç Files with Old Table References:

lib/database-diagnostics.ts ‚úÖ (We already fixed this)
lib/database.ts - Main database utilities file
app/api/business/test/route.ts - API test route
Various SQL scripts (these are likely for database setup/migration)

Let me check the main lib/database.ts file to see the references:Gget_file_contentsRequest{
  `owner`: `omarkt13`,
  `path`: `lib/database.ts`,
  `repo`: `SeaFable_v01`
}Response[{"type": "text", "text": "{\n  \"name\": \"database.ts\",\n  \"path\": \"lib/database.ts\",\n  \"sha\": \"64e9a46d89543e760db2130e00073f310475b5dc\",\n  \"size\": 43386,\n  \"url\": \"https://api.github.com/repos/omarkt13/SeaFable_v01/contents/lib/database.ts?ref=main\",\n  \"html_url\": \"https://github.com/omarkt13/SeaFable_v01/blob/main/lib/database.ts\",\n  \"git_url\": \"https://api.github.com/repos/omarkt13/SeaFable_v01/git/blobs/64e9a46d89543e760db2130e00073f310475b5dc\",\n  \"download_url\": \"https://raw.githubusercontent.com/omarkt13/SeaFable_v01/main/lib/database.ts\",\n  \"type\": \"file\",\n  \"content\": \"import { createClient } from \\\"@/lib/supabase/client\\\"\\nimport { createClient as createServerClient } from \\\"@/lib/supabase/server\\\"\\n\\n// Connection pool management\\nlet supabaseClient: ReturnType<typeof createClient> | null = null\\n\\nfunction getSupabaseClient() {\\n  if (!supabaseClient) {\\n    supabaseClient = createClient()\\n  }\\n  return supabaseClient\\n}\\n\\n// Retry mechanism for database operations\\nasync function withRetry<T>(\\n  operation: () => Promise<T>,\\n  maxRetries: number = 3,\\n  delay: number = 1000\\n): Promise<T> {\\n  let lastError: Error | null = null\\n\\n  for (let attempt = 1; attempt <= maxRetries; attempt++) {\\n    try {\\n      return await operation()\\n    } catch (error) {\\n      lastError = error as Error\\n      console.warn(`Database operation failed (attempt ${attempt}/${maxRetries}):`, error)\\n\\n      if (attempt === maxRetries) {\\n        throw lastError\\n      }\\n\\n      // Exponential backoff\\n      await new Promise(resolve => setTimeout(resolve, delay * Math.pow(2, attempt - 1)))\\n    }\\n  }\\n\\n  throw lastError\\n}\\n\\nconst supabase = getSupabaseClient()\\nimport type { BusinessProfile } from \\\"../types/auth\\\"\\nimport type { HostProfile as SupabaseHostProfile } from \\\"@/lib/supabase\\\"\\nimport type { HostAvailability } from \\\"@/types/business\\\" // Import HostAvailability type\\n\\n// \u2705 FIXED: Added input sanitization helper\\nfunction sanitizeInput(input: string): string {\\n  return input\\n    .replace(/[<>]/g, \\\"\\\") // Remove HTML tags\\n    .replace(/['\\\"`;]/g, \\\"\\\") // Remove SQL injection chars\\n    .trim()\\n    .substring(0, 200) // Limit length\\n}\\n\\n// Authentication functions\\nexport interface Experience {\\n  id: string\\n  host_id: string\\n  title: string\\n  description: string\\n  short_description?: string\\n  location: string\\n  specific_location?: string\\n  country?: string\\n  activity_type: string\\n  category: string[]\\n  duration_hours: number\\n  duration_display?: string\\n  max_guests: number\\n  min_guests: number\\n  price_per_person: number\\n  difficulty_level: string\\n  rating: number\\n  total_reviews: number\\n  total_bookings: number\\n  primary_image_url?: string\\n  weather_contingency?: string\\n  included_amenities: string[]\\n  what_to_bring: string[]\\n  min_age?: number\\n  max_age?: number\\n  age_restriction_details?: string\\n  activity_specific_details?: any\\n  tags: string[]\\n  seasonal_availability: string[]\\n  is_active: boolean\\n  created_at: string\\n  updated_at: string\\n  host_profiles?: SupabaseHostProfile\\n  experience_images?: ExperienceImage[]\\n  reviews?: Review[]\\n  itinerary?: any // Add this line\\n  host_availability?: HostAvailability[] // Add host_availability to Experience interface\\n}\\n\\nexport interface HostProfile {\\n  id: string\\n  user_id?: string\\n  name: string\\n  bio?: string\\n  avatar_url?: string\\n  years_experience: number\\n  certifications: string[]\\n  specialties: string[]\\n  rating: number\\n  total_reviews: number\\n  host_type: string\\n  languages_spoken: string[]\\n  business_name?: string\\n  contact_name?: string\\n  email?: string\\n  phone?: string\\n  business_type?: string\\n  location?: string\\n  description?: string\\n  business_registration_id?: string\\n  insurance_details?: string\\n  created_at: string\\n  updated_at: string\\n}\\n\\nexport interface ExperienceImage {\\n  id: string\\n  experience_id: string\\n  image_url: string\\n  alt_text?: string\\n  display_order: number\\n  created_at: string\\n}\\n\\nexport interface Review {\\n  id: string\\n  booking_id: string\\n  user_id: string\\n  experience_id: string\\n  host_id: string\\n  rating: number\\n  title?: string\\n  comment?: string\\n  pros?: string[]\\n  cons?: string[]\\n  would_recommend?: boolean\\n  verified_booking: boolean\\n  helpful_votes: number\\n  response_from_host_comment?: string\\n  response_from_host_at?: string\\n  created_at: string\\n  updated_at: string\\n  users?: {\\n    first_name: string\\n    last_name: string\\n    avatar_url?: string\\n  }\\n}\\n\\nexport interface Booking {\\n  id: string\\n  user_id: string\\n  experience_id: string\\n  host_id: string\\n  booking_date: string\\n  departure_time?: string\\n  number_of_guests: number\\n  guest_details?: any\\n  total_price: number\\n  booking_status: string\\n  special_requests?: string\\n  dietary_requirements: string[]\\n  payment_id?: string\\n  payment_method?: string\\n  payment_status: string\\n  amount_paid?: number\\n  currency: string\\n  booked_at: string\\n  updated_at: string\\n  experiences?: {\\n    id: string\\n    title: string\\n    location: string\\n    primary_image_url?: string\\n    duration_display?: string\\n    activity_type: string\\n  }\\n  users?: {\\n    first_name: string\\n    last_name: string\\n    email: string\\n    avatar_url?: string\\n    // phone?: string // Added phone to user type for upcoming bookings\\n  }\\n  host_profiles?: {\\n    id: string\\n    name: string\\n    avatar_url?: string\\n  }\\n}\\n\\n// Define dashboard data types\\nexport interface BusinessDashboardData {\\n  businessProfile: SupabaseHostProfile | null\\n  overview: {\\n    totalRevenue: number\\n    activeBookings: number\\n    totalExperiences: number\\n    averageRating: number\\n    revenueGrowth: number\\n    bookingGrowth: number\\n  }\\n  recentBookings: Array<{\\n    id: string\\n    customerName: string\\n    experienceTitle: string\\n    date: string\\n    amount: number\\n    guests: number\\n    avatar: string\\n    status: string\\n  }>\\n  upcomingBookings: Array<{\\n    id: string\\n    customerName: string\\n    experienceTitle: string\\n    date: string\\n    time: string\\n    guests: number\\n    specialRequests: string\\n    phone: string\\n  }>\\n  earnings: {\\n    thisMonth: number\\n    lastMonth: number\\n    pending: number\\n    nextPayout: { amount: number; date: string }\\n    monthlyTrend: { month: string; revenue: number }[]\\n  }\\n  analytics: {\\n    conversionRate: number\\n    customerSatisfaction: number\\n    repeatCustomerRate: number\\n    marketplaceVsDirectRatio: number\\n    metricsTrend: { name: string; value: number }[]\\n  }\\n  experiences: Array<{\\n    id: string\\n    title: string\\n    status: \\\"active\\\" | \\\"inactive\\\"\\n    bookings: number\\n    revenue: number\\n    rating: number\\n  }>\\n  recentActivity: { description: string; time: string; color: string }[]\\n}\\n\\nexport async function signInUser(email: string, password: string) {\\n  try {\\n    const { data, error } = await supabase.auth.signInWithPassword({\\n      email,\\n      password,\\n    })\\n\\n    if (error) {\\n      return { success: false, error: error.message }\\n    }\\n\\n    return { success: true, data }\\n  } catch (error: any) {\\n    console.error(\\\"Sign in error:\\\", error)\\n    return { success: false, error: \\\"Network error occurred\\\" }\\n  }\\n}\\n\\nexport async function signOutUser() {\\n  try {\\n    const { error } = await supabase.auth.signOut()\\n    if (error) {\\n      console.error(\\\"Sign out error:\\\", error)\\n      return { success: false, error: error.message }\\n    }\\n    return { success: true }\\n  } catch (error: any) {\\n    console.error(\\\"Sign out error:\\\", error)\\n    return { success: false, error: \\\"Network error occurred\\\" }\\n  }\\n}\\n\\n// Experience functions\\nexport interface ExperienceData {\\n  host_id: string\\n  title: string\\n  description: string\\n  short_description: string\\n  location: string\\n  specific_location?: string\\n  country?: string\\n  activity_type: string\\n  category: string[]\\n  duration_hours: number\\n  max_guests: number\\n  min_guests: number\\n  price_per_person: number\\n  difficulty_level: string\\n  included_amenities: string[]\\n  what_to_bring: string[]\\n  min_age?: number\\n  max_age?: number\\n  age_restriction_details?: string\\n  activity_specific_details?: any\\n  tags: string[]\\n  seasonal_availability: string[]\\n  itinerary: Array<{ time: string; activity: string; description?: string }>\\n  primary_image_url?: string\\n  weather_contingency?: string\\n  is_active?: boolean\\n}\\n\\nexport async function createExperience(experienceData: ExperienceData) {\\n  try {\\n    // First, get the host profile ID using the provided host_id (which is actually user_id)\\n    const { data: hostProfile, error: hostError } = await supabase\\n      .from(\\\"host_profiles\\\")\\n      .select(\\\"id\\\")\\n      .eq(\\\"user_id\\\", experienceData.host_id)\\n      .single()\\n\\n    if (hostError || !hostProfile) {\\n      console.error(\\\"Host profile not found:\\\", hostError)\\n      return { success: false, error: \\\"Host profile not found. Please complete business registration first.\\\" }\\n    }\\n\\n    // Prepare the experience data with proper host_id (the host_profile.id)\\n    const experienceInsertData = {\\n      host_id: hostProfile.id, // Use the host_profiles.id, not user_id\\n      title: experienceData.title,\\n      description: experienceData.description,\\n      short_description: experienceData.short_description || experienceData.description.substring(0, 150) + '...',\\n      location: experienceData.location,\\n      specific_location: experienceData.specific_location,\\n      country: experienceData.country,\\n      activity_type: experienceData.activity_type,\\n      category: experienceData.category || [],\\n      duration_hours: experienceData.duration_hours,\\n      duration_display: experienceData.duration_display || `${experienceData.duration_hours} hours`,\\n      max_guests: experienceData.max_guests,\\n      min_guests: experienceData.min_guests,\\n      price_per_person: experienceData.price_per_person,\\n      difficulty_level: experienceData.difficulty_level,\\n      primary_image_url: experienceData.primary_image_url,\\n      weather_contingency: experienceData.weather_contingency,\\n      included_amenities: experienceData.included_amenities || [],\\n      what_to_bring: experienceData.what_to_bring || [],\\n      min_age: experienceData.min_age,\\n      max_age: experienceData.max_age,\\n      age_restriction_details: experienceData.age_restriction_details,\\n      activity_specific_details: experienceData.activity_specific_details || {},\\n      tags: experienceData.tags || [],\\n      seasonal_availability: experienceData.seasonal_availability || [],\\n      is_active: experienceData.is_active ?? true,\\n      rating: 0,\\n      total_reviews: 0,\\n      total_bookings: 0,\\n      created_at: new Date().toISOString(),\\n      updated_at: new Date().toISOString(),\\n    }\\n\\n    // Insert the experience\\n    const { data: newExperience, error } = await supabase\\n      .from(\\\"experiences\\\")\\n      .insert([experienceInsertData])\\n      .select()\\n      .single()\\n\\n    if (error) {\\n      console.error(\\\"Database error creating experience:\\\", error)\\n      return { success: false, error: error.message }\\n    }\\n\\n    // If itinerary is provided, create default availability slots\\n    if (experienceData.itinerary && experienceData.itinerary.length > 0) {\\n      try {\\n        // Create some default availability slots for the next 30 days\\n        const availabilitySlots = []\\n        const today = new Date()\\n\\n        for (let i = 1; i <= 30; i++) {\\n          const date = new Date(today)\\n          date.setDate(today.getDate() + i)\\n\\n          // Create morning and afternoon slots\\n          const morningSlot = {\\n            host_profile_id: hostProfile.id,\\n            experience_id: newExperience.id,\\n            date: date.toISOString().split('T')[0],\\n            start_time: '09:00:00',\\n            end_time: `${9 + experienceData.duration_hours}:00:00`,\\n            available_capacity: experienceData.max_guests,\\n            created_at: new Date().toISOString(),\\n            updated_at: new Date().toISOString(),\\n          }\\n\\n          const afternoonSlot = {\\n            host_profile_id: hostProfile.id,\\n            experience_id: newExperience.id,\\n            date: date.toISOString().split('T')[0],\\n            start_time: '14:00:00',\\n            end_time: `${14 + experienceData.duration_hours}:00:00`,\\n            available_capacity: experienceData.max_guests,\\n            created_at: new Date().toISOString(),\\n            updated_at: new Date().toISOString(),\\n          }\\n\\n          availabilitySlots.push(morningSlot, afternoonSlot)\\n        }\\n\\n        // Insert availability slots with better error handling\\n        if (availabilitySlots.length > 0) {\\n          try {\\n            const { error: availabilityError } = await supabase\\n              .from(\\\"host_availability\\\")\\n              .insert(availabilitySlots)\\n\\n            if (availabilityError) {\\n              console.warn(\\\"Error creating default availability slots:\\\", availabilityError)\\n              // Check if table exists or has correct structure\\n              if (availabilityError.code === '42703') {\\n                console.error(\\\"Column missing in host_availability table:\\\", availabilityError.message)\\n              }\\n              // Don't fail the experience creation for availability issues\\n            } else {\\n              console.log(`Created ${availabilitySlots.length} availability slots for experience ${newExperience.id}`)\\n            }\\n          } catch (availError) {\\n            console.warn(\\\"Unexpected error creating availability:\\\", availError)\\n          }\\n        }\\n      } catch (availabilityError) {\\n        console.warn(\\\"Error creating availability:\\\", availabilityError)\\n        // Continue without failing\\n      }\\n    }\\n\\n    return { success: true, data: newExperience }\\n  } catch (error: any) {\\n    console.error(\\\"Unexpected error creating experience:\\\", error)\\n    return { success: false, error: error.message || \\\"An unexpected error occurred\\\" }\\n  }\\n}\\n\\nexport async function getExperiences(filters?: any) {\\n  try {\\n    let query = supabase\\n      .from(\\\"experiences\\\")\\n      .select(`\\n        *,\\n        host_profiles!experiences_host_id_fkey (\\n          id,\\n          name,\\n          avatar_url,\\n          rating,\\n          total_reviews\\n        )\\n      `)\\n      .eq(\\\"is_active\\\", true)\\n\\n    // Handle legacy hostId parameter (when filters is a string)\\n    if (typeof filters === \\\"string\\\") {\\n      query = query.eq(\\\"host_id\\\", filters)\\n    } else if (filters && typeof filters === \\\"object\\\") {\\n      // Handle search filters object\\n      if (filters.search) {\\n        query = query.or(`title.ilike.%${filters.search}%, description.ilike.%${filters.search}%`)\\n      }\\n\\n      if (filters.location) {\\n        query = query.or(`location.ilike.%${filters.location}%, country.ilike.%${filters.location}%`)\\n      }\\n\\n      if (filters.activityTypes && filters.activityTypes.length > 0) {\\n        query = query.in(\\\"activity_type\\\", filters.activityTypes)\\n      }\\n\\n      if (filters.priceRange && filters.priceRange.length === 2) {\\n        query = query.gte(\\\"price_per_person\\\", filters.priceRange[0])\\n        if (filters.priceRange[1] < 500) {\\n          query = query.lte(\\\"price_per_person\\\", filters.priceRange[1])\\n        }\\n      }\\n\\n      if (filters.difficultyLevels && filters.difficultyLevels.length > 0) {\\n        query = query.in(\\\"difficulty_level\\\", filters.difficultyLevels)\\n      }\\n\\n      if (filters.minGuests) {\\n        query = query.gte(\\\"max_guests\\\", filters.minGuests)\\n      }\\n\\n      if (filters.rating) {\\n        query = query.gte(\\\"rating\\\", filters.rating)\\n      }\\n\\n      if (filters.hostId) {\\n        query = query.eq(\\\"host_id\\\", filters.hostId)\\n      }\\n    }\\n\\n    // Apply sorting\\n    if (filters && filters.sortBy) {\\n      switch (filters.sortBy) {\\n        case \\\"price_low\\\":\\n          query = query.order(\\\"price_per_person\\\", { ascending: true })\\n          break\\n        case \\\"price_high\\\":\\n          query = query.order(\\\"price_per_person\\\", { ascending: false })\\n          break\\n        case \\\"rating\\\":\\n          query = query.order(\\\"rating\\\", { ascending: false })\\n          break\\n        case \\\"reviews\\\":\\n          query = query.order(\\\"total_reviews\\\", { ascending: false })\\n          break\\n        case \\\"popular\\\":\\n          query = query.order(\\\"total_bookings\\\", { ascending: false })\\n          break\\n        case \\\"newest\\\":\\n          query = query.order(\\\"created_at\\\", { ascending: false })\\n          break\\n        default:\\n          query = query.order(\\\"rating\\\", { ascending: false }).order(\\\"total_bookings\\\", { ascending: false })\\n          break\\n      }\\n    } else {\\n      query = query.order(\\\"created_at\\\", { ascending: false })\\n    }\\n\\n    const { data, error } = await query\\n\\n    if (error) {\\n      console.error(\\\"Database error:\\\", error)\\n      return { success: false, error: error.message }\\n    }\\n\\n    return { success: true, data }\\n  } catch (error: any) {\\n    console.error(\\\"Unexpected error:\\\", error)\\n    return { success: false, error: error.message || \\\"An unexpected error occurred\\\" }\\n  }\\n}\\n\\n// Host-specific experiences function\\nexport async function getHostExperiences(hostId: string) {\\n  return getExperiences({ hostId })\\n}\\n\\nexport async function getExperienceById(id: string) {\\n  try {\\n    const { data, error } = await supabase.from(\\\"experiences\\\").select(\\\"*\\\").eq(\\\"id\\\", id).single()\\n\\n    if (error) {\\n      console.error(\\\"Database error:\\\", error)\\n      return { success: false, error: error.message }\\n    }\\n\\n    return { success: true, data }\\n  } catch (error: any) {\\n    console.error(\\\"Unexpected error:\\\", error)\\n    return { success: false, error: error.message || \\\"An unexpected error occurred\\\" }\\n  }\\n}\\n\\nexport async function updateExperience(\\n  experienceId: string,\\n  updates: Partial<{\\n    title: string\\n    description: string\\n    short_description: string\\n    location: string\\n    specific_location: string\\n    country: string\\n    activity_type: string\\n    category: string[]\\n    duration_hours: number\\n    duration_display: string\\n    max_guests: number\\n    min_guests: number\\n    price_per_person: number\\n    difficulty_level: string\\n    primary_image_url: string\\n    weather_contingency: string\\n    included_amenities: string[]\\n    what_to_bring: string[]\\n    min_age: number | null\\n    max_age: number | null\\n    age_restriction_details: string\\n    activity_specific_details: any\\n    tags: string[]\\n    seasonal_availability: string[]\\n    is_active: boolean\\n    itinerary: any\\n  }>\\n) {\\n  try {\\n    const { data, error } = await supabase\\n      .from(\\\"experiences\\\")\\n      .update({\\n        ...updates,\\n        updated_at: new Date().toISOString(),\\n      })\\n      .eq(\\\"id\\\", experienceId)\\n      .select()\\n      .single()\\n\\n    if (error) {\\n      console.error(\\\"Database error updating experience:\\\", error)\\n      throw new Error(error.message)\\n    }\\n\\n    return data\\n  } catch (error: any) {\\n    console.error(\\\"Unexpected error updating experience:\\\", error)\\n    throw new Error(error.message || \\\"An unexpected error occurred\\\")\\n  }\\n}\\n\\nexport async function getExperienceReviews(experienceId: string) {\\n  try {\\n    const { data, error } = await supabase\\n      .from(\\\"reviews\\\")\\n      .select(`\\n        *,\\n        users!reviews_user_id_fkey (\\n          first_name,\\n          last_name,\\n          avatar_url\\n        )\\n      `)\\n      .eq(\\\"experience_id\\\", experienceId)\\n      .order(\\\"created_at\\\", { ascending: false })\\n\\n    if (error) {\\n      console.error(\\\"Error fetching reviews:\\\", error)\\n      return { success: false, error: error.message, data: [] }\\n    }\\n\\n    return { success: true, data: data || [] }\\n  } catch (error) {\\n    console.error(\\\"Error fetching reviews:\\\", error)\\n    return { success: false, error: \\\"Network error occurred\\\", data: [] }\\n  }\\n}\\n\\nexport async function getUserBookings(userId: string) {\\n  try {\\n    const { data, error } = await supabase\\n      .from(\\\"bookings\\\")\\n      .select(`\\n        *,\\n        experiences (\\n          id,\\n          title,\\n          location,\\n          primary_image_url,\\n          duration_display,\\n          activity_type\\n        ),\\n        host_profiles (\\n          id,\\n          name,\\n          avatar_url\\n        )\\n      `)\\n      .eq(\\\"user_id\\\", userId)  // For regular users, userId matches bookings.user_id\\n      .order(\\\"booking_date\\\", { ascending: false })\\n\\n    if (error) {\\n      console.error(\\\"Error fetching user bookings:\\\", error)\\n      return { success: false, error: error.message, data: [] }\\n    }\\n\\n    return { success: true, data: data || [] }\\n  } catch (error) {\\n    console.error(\\\"Error fetching user bookings:\\\", error)\\n    return { success: false, error: \\\"Network error occurred\\\", data: [] }\\n  }\\n}\\n\\nexport async function getHostBookings(hostId: string): Promise<Booking[]> {\\n  try {\\n    // For business users, hostId directly matches the host_id in bookings\\n    const { data, error } = await supabase\\n      .from(\\\"bookings\\\")\\n      .select(`\\n        *,\\n        experiences ( \\n          id, \\n          title, \\n          location,\\n          primary_image_url, \\n          duration_display, \\n          activity_type \\n        ),\\n        users ( \\n          first_name, \\n          last_name, \\n          email,\\n          avatar_url \\n        )\\n      `)\\n      .eq(\\\"host_id\\\", hostId)\\n      .order(\\\"booking_date\\\", { ascending: true })\\n\\n    if (error) {\\n      console.error(\\\"Error fetching host bookings:\\\", error)\\n      return []\\n    }\\n\\n    // Ensure data is an array and properly formatted\\n    if (!Array.isArray(data)) {\\n      console.warn(\\\"Bookings data is not an array:\\\", data)\\n      return []\\n    }\\n\\n    // Transform the data to ensure consistent structure\\n    const transformedBookings = data.map(booking => ({\\n      ...booking,\\n      experiences: booking.experiences || { \\n        id: '', \\n        title: 'Unknown Experience', \\n        location: '',\\n        primary_image_url: null, \\n        duration_display: '',\\n        activity_type: '' \\n      },\\n      users: booking.users || { \\n        first_name: 'Unknown', \\n        last_name: 'Guest', \\n        email: '',\\n        avatar_url: null \\n      }\\n    }))\\n\\n    return transformedBookings\\n  } catch (error: any) {\\n    console.error(\\\"Unexpected error fetching bookings:\\\", error)\\n    return []\\n  }\\n}\\n\\nexport async function getHostEarnings(hostId: string) {\\n  const { data, error } = await supabase\\n    .from(\\\"bookings\\\")\\n    .select(\\n      `\\n        total_price,\\n        payment_status,\\n        booked_at\\n      `,\\n    )\\n    .eq(\\\"host_id\\\", hostId)\\n    .eq(\\\"payment_status\\\", \\\"succeeded\\\") // Only count succeeded payments\\n    .order(\\\"booked_at\\\", { ascending: false })\\n\\n  if (error) {\\n    console.error(\\\"Error fetching host earnings:\\\", error)\\n    return { data: null, error: error.message }\\n  }\\n\\n  return { data, error: null }\\n}\\n\\n// Optimized host dashboard data function\\nexport async function getUserDashboardData(userId: string): Promise<{ success: boolean; data?: { user: any, bookings: any[], reviews: any[] }; error?: string }> {\\n  try {\\n    const supabase = createClient()\\n\\n    // Get user profile\\n    const { data: userProfile, error: userError } = await supabase\\n      .from('user_profiles')\\n      .select('*')\\n      .eq('id', userId)\\n      .single()\\n\\n    if (userError && userError.code !== 'PGRST116') {\\n      console.error(\\\"Error fetching user profile:\\\", userError)\\n      return { success: false, error: userError.message }\\n    }\\n\\n    // Get user bookings\\n    const { data: bookings, error: bookingsError } = await supabase\\n      .from('bookings')\\n      .select(`\\n        *,\\n        experiences (\\n          id,\\n          title,\\n          location,\\n          price_per_person,\\n          images\\n        )\\n      `)\\n      .eq('user_id', userId)\\n      .order('created_at', { ascending: false })\\n\\n    if (bookingsError) {\\n      console.error(\\\"Error fetching bookings:\\\", bookingsError)\\n      return { success: false, error: bookingsError.message }\\n    }\\n\\n    // Get user reviews\\n    const { data: reviews, error: reviewsError } = await supabase\\n      .from('reviews')\\n      .select(`\\n        *,\\n        experiences (\\n          id,\\n          title,\\n          images\\n        )\\n      `)\\n      .eq('user_id', userId)\\n      .order('created_at', { ascending: false })\\n\\n    if (reviewsError) {\\n      console.error(\\\"Error fetching reviews:\\\", reviewsError)\\n      return { success: false, error: reviewsError.message }\\n    }\\n\\n    return {\\n      success: true,\\n      data: {\\n        user: userProfile,\\n        bookings: bookings || [],\\n        reviews: reviews || []\\n      }\\n    }\\n  } catch (error) {\\n    console.error(\\\"Error in getUserDashboardData:\\\", error)\\n    return { success: false, error: \\\"Failed to fetch dashboard data\\\" }\\n  }\\n}\\n\\nexport async function getHostDashboardData(userId: string) {\\n  try {\\n    const supabase = createClient()\\n\\n    // For business users, try both user_id and id mapping\\n    let businessProfile = null\\n    let profileError = null\\n\\n    // First try: lookup by user_id (new business users)\\n    const { data: profileByUserId, error: userIdError } = await supabase\\n      .from('host_profiles')\\n      .select('*')\\n      .eq('user_id', userId)\\n      .single()\\n\\n    if (!userIdError && profileByUserId) {\\n      businessProfile = profileByUserId\\n    } else {\\n      // Second try: lookup by id (existing business users)\\n      const { data: profileById, error: idError } = await supabase\\n        .from('host_profiles')\\n        .select('*')\\n        .eq('id', userId)\\n        .single()\\n\\n      if (!idError && profileById) {\\n        businessProfile = profileById\\n      } else {\\n        profileError = userIdError || idError\\n      }\\n    }\\n\\n    if (!businessProfile) {\\n      console.error('Profile lookup failed:', { userIdError, profileError })\\n      return { \\n        success: false, \\n        error: 'Business profile not found. Please complete your business registration.',\\n        details: {\\n          userId,\\n          userIdError: userIdError?.message,\\n          idError: profileError?.message\\n        }\\n      }\\n    }\\nconst hostId = businessProfile.id\\n\\n    // Get experiences with error handling\\n    const { data: experiences, error: expError } = await supabase\\n      .from('experiences')\\n      .select('*')\\n      .eq('host_id', hostId)\\n\\n    if (expError) {\\n      console.error('Experiences query error:', expError)\\n    }\\n\\n    // Get bookings with related data and comprehensive error handling\\n    const { data: bookings, error: bookingError } = await supabase\\n      .from('bookings')\\n      .select(`\\n        id,\\n        user_id,\\n        experience_id,\\n        host_id,\\n        booking_date,\\n        number_of_guests,\\n        total_price,\\n        booking_status,\\n        created_at,\\n        experiences (\\n          id,\\n          title,\\n          price_per_person\\n        ),\\n        users (\\n          first_name,\\n          last_name,\\n          email\\n        )\\n      `)\\n      .eq('host_id', hostId)\\n      .order('created_at', { ascending: false })\\n      .limit(10)\\n\\n    if (bookingError) {\\n      console.error('Bookings query error:', bookingError)\\n    }\\n// Calculate metrics with safe defaults\\n    const safeBookings = bookings || []\\n    const safeExperiences = experiences || []\\n\\n    const totalRevenue = safeBookings.reduce((sum, booking) => {\\n      const price = booking?.total_price || 0\\n      return sum + (typeof price === 'number' ? price : 0)\\n    }, 0)\\n\\n    const activeBookings = safeBookings.filter(booking => \\n      booking?.booking_status === 'confirmed' || booking?.booking_status === 'pending'\\n    ).length\\n\\n    const recentBookings = safeBookings.slice(0, 5).map(booking => ({\\n      id: booking.id,\\n      user_id: booking.user_id,\\n      experience_id: booking.experience_id,\\n      booking_date: booking.booking_date,\\n      number_of_guests: booking.number_of_guests || 1,\\n      total_price: booking.total_price || 0,\\n      booking_status: booking.booking_status || 'pending',\\n      created_at: booking.created_at,\\n      experience_title: booking.experiences?.title || 'Unknown Experience',\\n      customer_name: booking.users ? \\n        `${booking.users.first_name || ''} ${booking.users.last_name || ''}`.trim() || 'Unknown Customer'\\n        : 'Unknown Customer',\\n      customer_email: booking.users?.email || ''\\n    }))\\nconst dashboardData = {\\n      businessProfile: {\\n        id: businessProfile.id,\\n        name: businessProfile.name || 'Unnamed Business',\\n        email: businessProfile.email || '',\\n        phone: businessProfile.phone || '',\\n        host_type: businessProfile.host_type || 'business',\\n        location: businessProfile.location || ''\\n      },\\n      overview: {\\n        totalRevenue: Math.round(totalRevenue * 100) / 100, // Round to 2 decimal places\\n        activeBookings,\\n        totalExperiences: safeExperiences.length,\\n        totalBookings: safeBookings.length\\n      },\\n      recentBookings,\\n      experiences: safeExperiences.map(exp => ({\\n        id: exp.id,\\n        title: exp.title || 'Untitled Experience',\\n        description: exp.description || '',\\n        price_per_person: exp.price_per_person || 0,\\n        location: exp.location || '',\\n        activity_type: exp.activity_type || 'other',\\n        status: exp.status || 'draft'\\n      })),\\n      debug: {\\n        hostId,\\n        experiencesCount: safeExperiences.length,\\n        bookingsCount: safeBookings.length,\\n        experiencesError: expError?.message,\\n        bookingsError: bookingError?.message\\n      }\\n    }\\n\\n    return {\\n      success: true,\\n      data: dashboardData\\n    }\\n  } catch (error: any) {\\n    console.error(\\\"Error fetching host dashboard data:\\\", error)\\n    return { success: false, error: error.message, data: null }\\n  }\\n}\\n\\n// Get user dashboard data\\nexport async function getUserDashboardDataOriginal(userId: string) {\\n  try {\\n    // Get user profile using the centralized function from auth-utils\\n    const user = await getUserProfile(userId)\\n\\n    if (!user) {\\n      console.error(\\\"Error fetching user: User profile not found for ID\\\", userId)\\n      return { success: false, error: \\\"User profile not found\\\", data: null }\\n    }\\n\\n    // Get user bookings\\n    const bookingsResult = await getUserBookings(userId)\\n\\n    // Get user reviews\\n    const { data: reviews, error: reviewError } = await supabase\\n      .from(\\\"reviews\\\")\\n      .select(`\\n        *,\\n        experiences!reviews_experience_id_fkey (title, primary_image_url)\\n      `)\\n      .eq(\\\"user_id\\\", userId)\\n      .order(\\\"created_at\\\", { ascending: false })\\n\\n    if (reviewError) {\\n      console.error(\\\"Error fetching reviews:\\\", reviewError)\\n    }\\n\\n    return {\\n      success: true,\\n      data: {\\n        user,\\n        bookings: bookingsResult.data || [],\\n        reviews: reviews || [],\\n      },\\n    }\\n  } catch (error) {\\n    console.error(\\\"Error fetching user dashboard data:\\\", error)\\n    return { success: false, error: \\\"Network error occurred\\\", data: null }\\n  }\\n}\\n\\n// Booking functions\\nexport async function createBooking(bookingData: {\\n  user_id: string\\n  experience_id: string\\n  host_id: string\\n  booking_date: string\\n  departure_time?: string\\n  number_of_guests: number\\n  guest_details?: any\\n  total_price: number\\n  special_requests?: string\\n  dietary_requirements?: string[]\\n}) {\\n  try {\\n    const { data, error } = await supabase\\n      .from(\\\"bookings\\\")\\n      .insert([\\n        {\\n          ...bookingData,\\n          booking_status: \\\"pending\\\",\\n          payment_status: \\\"pending\\\",\\n          currency: \\\"EUR\\\",\\n        },\\n      ])\\n      .select()\\n      .single()\\n\\n    if (error) {\\n      console.error(\\\"Error creating booking:\\\", error)\\n      return { success: false, error: error.message, data: null }\\n    }\\n\\n    return { success: true, data }\\n  } catch (error: any) {\\n    console.error(\\\"Error creating booking:\\\", error)\\n    return { success: false, error: \\\"Network error occurred\\\", data: null }\\n  }\\n}\\n\\n// Database connection test functions\\nexport async function testDatabaseConnection() {\\n  try {\\n    const { data, error } = await supabase.from(\\\"user_profiles\\\").select(\\\"count\\\").limit(1)\\n\\n    if (error) {\\n      return { success: false, error: error.message }\\n    }\\n\\n    return { success: true, message: \\\"Database connection successful\\\" }\\n  } catch (error: any) {\\n    return { success: false, error: \\\"Network error occurred\\\" }\\n  }\\n}\\n\\nexport async function testTableAccess() {\\n  const tables = [\\n    \\\"user_profiles\\\",\\n    \\\"host_profiles\\\",\\n    \\\"experiences\\\",\\n    \\\"bookings\\\",\\n    \\\"reviews\\\",\\n    \\\"host_business_settings\\\",\\n    \\\"host_availability\\\",\\n    \\\"experience_images\\\",\\n  ]\\n\\n  const results: { [key: string]: { success: boolean; error?: string; count?: number } } = {}\\n\\n  for (const table of tables) {\\n    try {\\n      const { data, error } = await supabase.from(table).select(\\\"*\\\").limit(1)\\n\\n      if (error) {\\n        results[table] = { success: false, error: error.message }\\n      } else {\\n        results[table] = { success: true, count: data?.length || 0 }\\n      }\\n    } catch (error: any) {\\n      results[table] = { success: false, error: `Network error: ${error.message}` }\\n    }\\n  }\\n\\n  return results\\n}\\n\\nexport async function getSampleData() {\\n  try {\\n    const [usersResult, experiencesResult, bookingsResult] = await Promise.all([\\n      supabase.from(\\\"user_profiles\\\").select(\\\"*\\\").limit(3),\\n      supabase.from(\\\"experiences\\\").select(\\\"*, host_profiles(name)\\\").limit(3),\\n      supabase.from(\\\"bookings\\\").select(\\\"*, experiences(title), user_profiles(first_name, last_name)\\\").limit(3),\\n    ])\\n\\n    return {\\n      users: usersResult.data || [],\\n      experiences: experiencesResult.data || [],\\n      bookings: bookingsResult.data || [],\\n    }\\n  } catch (error) {\\n    console.error(\\\"Error fetching sample data:\\\", error)\\n    return {\\n      users: [],\\n      experiences: [],\\n      bookings: [],\\n    }\\n  }\\n}\\n\\nexport async function updateBusinessProfile(userId: string, updates: Partial<BusinessProfile>) {\\n  const hostProfileUpdates: Partial<Omit<BusinessProfile, \\\"onboarding_completed\\\" | \\\"marketplace_enabled\\\">> = {}\\n  const hostBusinessSettingsUpdates: { onboarding_completed?: boolean; marketplace_enabled?: boolean } = {}\\n\\n  // Distribute updates to the correct tables\\n  if (updates.contact_name !== undefined) hostProfileUpdates.contact_name = updates.contact_name\\n  if (updates.phone !== undefined) hostProfileUpdates.phone = updates.phone\\n  if (updates.location !== undefined) hostProfileUpdates.location = updates.location\\n  if (updates.business_type !== undefined) hostProfileUpdates.business_type = updates.business_type\\n  if (updates.name !== undefined) hostProfileUpdates.name = updates.name\\n\\n  if (updates.onboarding_completed !== undefined)\\n    hostBusinessSettingsUpdates.onboarding_completed = updates.onboarding_completed\\n  if (updates.marketplace_enabled !== undefined)\\n    hostBusinessSettingsUpdates.marketplace_enabled = updates.marketplace_enabled\\n\\n  let hostProfileResult = null\\n  let settingsResult = null\\n\\n  // Update host_profiles table\\n  if (Object.keys(hostProfileUpdates).length > 0) {\\n    const { data, error } = await supabase\\n      .from(\\\"host_profiles\\\")\\n      .update(hostProfileUpdates)\\n      .eq(\\\"id\\\", userId)\\n      .select()\\n      .single()\\n\\n    if (error) {\\n      console.error(\\\"Error updating host profile:\\\", error)\\n      throw error\\n    }\\n    hostProfileResult = data\\n  }\\n\\n  // Update host_business_settings table\\n  if (Object.keys(hostBusinessSettingsUpdates).length > 0) {\\n    const { data, error } = await supabase\\n      .from(\\\"host_business_settings\\\")\\n      .update(hostBusinessSettingsUpdates)\\n      .eq(\\\"host_profile_id\\\", userId)\\n      .select()\\n      .single()\\n\\n    if (error) {\\n      console.error(\\\"Error updating host business settings:\\\", error)\\n      throw error\\n    }\\n    settingsResult = data\\n  }\\n\\n  return { success: true, hostProfile: hostProfileResult, settings: settingsResult }\\n}\\n\\n// Helper function to get user profile\\nexport async function getUserProfile(userId: string) {\\n  const supabase = createClient()\\n\\n  try {\\n    const { data, error } = await supabase\\n      .from('users')  // Fixed: use users table instead of user_profiles\\n      .select('*')\\n      .eq('id', userId)  // Fixed: use id field for regular users\\n      .single()\\n\\n    if (error) {\\n      console.error('Error fetching user profile:', error)\\n      // If table doesn't exist or no profile found, return a default profile structure\\n      if (error.code === '42P01' || error.code === 'PGRST116') {\\n        return {\\n          id: userId,\\n          first_name: '',\\n          last_name: '',\\n          email: '',\\n          avatar_url: null,\\n          role: 'user',\\n          created_at: new Date().toISOString(),\\n          updated_at: new Date().toISOString(),\\n          bio: null,\\n          phone_number: null,\\n          location: null,\\n          date_of_birth: null,\\n          notifications_enabled: true,\\n          newsletter_enabled: false,\\n          marketing_enabled: false\\n        }\\n      }\\n      return null\\n    }\\n\\n    return data\\n  } catch (error) {\\n    console.error('Unexpected error fetching user profile:', error)\\n    return null\\n  }\\n}\\nexport async function getBusinessDashboardData(businessId: string) {\\n  try {\\n    console.log(\\\"Fetching business dashboard data for:\\\", businessId)\\n\\n    // Get business profile\\n    const { data: businessProfile, error: profileError } = await supabase\\n      .from(\\\"host_profiles\\\")\\n      .select(\\\"*\\\")\\n      .eq(\\\"id\\\", businessId)\\n      .single()\\n\\n    if (profileError) {\\n      console.error(\\\"Error fetching business profile:\\\", profileError)\\n      throw profileError\\n    }\\n\\n    // Get business experiences\\n    const { data: experiences, error: experiencesError } = await supabase\\n      .from(\\\"experiences\\\")\\n      .select(\\\"*\\\")\\n      .eq(\\\"host_id\\\", businessId)\\n      .order(\\\"created_at\\\", { ascending: false })\\n\\n    if (experiencesError) {\\n      console.error(\\\"Error fetching experiences:\\\", experiencesError)\\n      throw experiencesError\\n    }\\n\\n    // Get bookings for this business\\n    const { data: bookings, error: bookingsError } = await supabase\\n      .from(\\\"bookings\\\")\\n      .select(`\\n        *,\\n        experiences!bookings_experience_id_fkey (\\n          title,\\n          location,\\n          primary_image_url\\n        )\\n      `)\\n      .eq(\\\"host_id\\\", businessId)\\n      .order(\\\"booking_date\\\", { ascending: false })\\n\\n    if (bookingsError) {\\n      console.error(\\\"Error fetching bookings:\\\", bookingsError)\\n      throw bookingsError\\n    }\\n\\n    // Calculate overview stats\\n    const totalExperiences = experiences?.length || 0\\n    const totalBookings = bookings?.length || 0\\n    const upcomingBookings = bookings?.filter(b => new Date(b.booking_date) >= new Date()) || []\\n    const completedBookings = bookings?.filter(b => new Date(b.booking_date) < new Date()) || []\\n    const totalRevenue = completedBookings.reduce((sum: number, booking: any) => sum + (booking.total_price || 0), 0)\\n\\n    // Get recent bookings (last 5)\\n    const recentBookings = bookings?.slice(0, 5) || []\\n\\n    // Mock analytics data for now\\n    const analytics = {\\n      totalViews: Math.floor(Math.random() * 1000) + 500,\\n      conversionRate: Math.round((totalBookings / Math.max(1, totalExperiences * 10)) * 100 * 100) / 100,\\n      averageRating: 4.8,\\n      responseTime: \\\"2 hours\\\"\\n    }\\n\\n    return {\\n      overview: {\\n        totalExperiences,\\n        totalBookings,\\n        upcomingBookings: upcomingBookings.length,\\n        totalRevenue,\\n        monthlyRevenue: Math.round(totalRevenue * 0.3), // Mock 30% of total as monthly\\n      },\\n      experiences: experiences || [],\\n      recentBookings: recentBookings,\\n      upcomingBookings: upcomingBookings.slice(0, 5),\\n      analytics,\\n      businessProfile,\\n      earnings: {\\n        thisMonth: Math.round(totalRevenue * 0.3),\\n        lastMonth: Math.round(totalRevenue * 0.25),\\n        growth: 20, // Mock growth percentage\\n        pendingPayouts: Math.round(totalRevenue * 0.1)\\n      },\\n      recentActivity: [\\n        { type: \\\"booking\\\", message: \\\"New booking received\\\", time: \\\"2 hours ago\\\" },\\n        { type: \\\"review\\\", message: \\\"5-star review received\\\", time: \\\"1 day ago\\\" },\\n        { type: \\\"experience\\\", message: \\\"Experience updated\\\", time: \\\"3 days ago\\\" }\\n      ]\\n    }\\n  } catch (error) {\\n    console.error(\\\"Error in getBusinessDashboardData:\\\", error)\\n    throw error\\n  }\\n}\\n\\nexport interface Review {\\n  id: string\\n  booking_id: string\\n  guest_email: string\\n  rating: number\\n  title: string\\n  comment: string\\n  created_at: string\\n}\\n\\nexport interface BusinessDashboardData {\\n  overview: {\\n    totalExperiences: number\\n    totalBookings: number\\n    upcomingBookings: number\\n    totalRevenue: number\\n    monthlyRevenue: number\\n  }\\n  experiences: any[]\\n  recentBookings: any[]\\n  upcomingBookings: any[]\\n  analytics: {\\n    totalViews: number\\n    conversionRate: number\\n    averageRating: number\\n    responseTime: string\\n  }\\n  businessProfile: any\\n  earnings: {\\n    thisMonth: number\\n    lastMonth: number\\n    growth: number\\n    pendingPayouts: number\\n  }\\n  recentActivity: Array<{\\n    type: string\\n    message: string\\n    time: string\\n  }>\\n}\\n\\nexport async function getWeeklyBookings() {\\n  const startOfWeek = new Date()\\n  startOfWeek.setDate(startOfWeek.getDate() - startOfWeek.getDay())\\n  startOfWeek.setHours(0, 0, 0, 0)\\n\\n  const endOfWeek = new Date(startOfWeek)\\n  endOfWeek.setDate(endOfWeek.getDate() + 6)\\n  endOfWeek.setHours(23, 59, 59, 999)\\n\\n  try {\\n    const { data, error } = await supabase\\n      .from('bookings')\\n      .select(`\\n        *,\\n        experiences (\\n          id,\\n          title,\\n          duration_hours\\n        ),\\n        users (\\n          first_name,\\n          last_name,\\n          email,\\n          phone\\n        )\\n      `)\\n      .gte('booking_date', startOfWeek.toISOString().split('T')[0])\\n      .lte('booking_date', endOfWeek.toISOString().split('T')[0])\\n      .order('booking_date', { ascending: true })\\n\\n    if (error) {\\n      console.error('Error fetching weekly bookings:', error)\\n      return []\\n    }\\n\\n    return Array.isArray(data) ? data : []\\n  } catch (error) {\\n    console.error('Unexpected error fetching weekly bookings:', error)\\n    return []\\n  }\\n}\\n\\nexport async function getRecentBookings(limit: number = 5) {\\n  const { data, error } = await supabase\\n    .from('bookings')\\n    .select(`\\n      *,\\n      host_profiles (\\n        name,\\n        contact_name,\\n        email\\n      ),\\n      experiences (\\n        title,\\n        location,\\n        duration\\n      )\\n    `)\\n    .order('created_at', { ascending: false })\\n    .limit(limit)\\n\\n  if (error) {\\n    console.error('Error fetching recent bookings:', error)\\n    return []\\n  }\\n\\n  return data || []\\n}\\nexport async function getUpcomingBookings(startDate: string) {\\n  const { data, error } = await supabase\\n    .from('bookings')\\n    .select(`\\n      *,\\n      users (\\n        first_name,\\n        last_name,\\n        email\\n      ),\\n      experiences (\\n        title,\\n        location,\\n        duration\\n      )\\n    `)\\n    .gte('booking_date', new Date().toISOString().split('T')[0])\\n    .order('booking_date', { ascending: true })\\n\\n  if (error) {\\n    console.error('Error fetching upcoming bookings:', error)\\n    return []\\n  }\\n\\n  return data || []\\n}\\n\\nexport async function fetchBusinessProfile(userId: string) {\\n  if (!userId) {\\n    throw new Error('User ID is required to fetch business profile')\\n  }\\n\\n  const supabase = createClient()\\n\\n  try {\\n    console.log('Fetching business profile for user ID:', userId)\\n\\n    const { data, error } = await supabase\\n      .from('business_profiles')\\n      .select('*')\\n      .eq('user_id', userId)\\n      .single()\\n\\n    if (error) {\\n      console.error('Error fetching business profile:', {\\n        code: error.code,\\n        message: error.message,\\n        details: error.details,\\n        hint: error.hint,\\n        userId\\n      })\\n\\n      // Handle specific error cases\\n      if (error.code === 'PGRST116') {\\n        throw new Error(`Business profile not found for user ${userId}. Please complete your business profile setup.`)\\n      } else if (error.code === '22P02') {\\n        throw new Error(`Invalid user ID format: ${userId}`)\\n      } else if (error.code === '42P01') {\\n        throw new Error('Business profiles table does not exist. Please check database setup.')\\n      }\\n\\n      throw new Error(`Database error: ${error.message}`)\\n    }\\n\\n    console.log('Business profile fetched successfully:', data)\\n    return data\\n  } catch (error) {\\n    console.error('Unexpected error fetching business profile:', {\\n      error: error instanceof Error ? error.message : error,\\n      stack: error instanceof Error ? error.stack : undefined,\\n      userId\\n    })\\n    throw error\\n  }\\n}\",\n  \"encoding\": \"base64\",\n  \"_links\": {\n    \"self\": \"https://api.github.com/repos/omarkt13/SeaFable_v01/contents/lib/database.ts?ref=main\",\n    \"git\": \"https://api.github.com/repos/omarkt13/SeaFable_v01/git/blobs/64e9a46d89543e760db2130e00073f310475b5dc\",\n    \"html\": \"https://github.com/omarkt13/SeaFable_v01/blob/main/lib/database.ts\"\n  }\n}", "uuid": "580e68b8-43ef-4711-bb2c-461b90e1a291"}]Perfect! I found the problem. Let me also check the API test route:Gget_file_contentsRequest{
  `owner`: `omarkt13`,
  `path`: `app/api/business/test/route.ts`,
  `repo`: `SeaFable_v01`
}Response[{"type": "text", "text": "{\n  \"name\": \"route.ts\",\n  \"path\": \"app/api/business/test/route.ts\",\n  \"sha\": \"f0a4576daa280f005d362d03b39c81bbef0a7643\",\n  \"size\": 788,\n  \"url\": \"https://api.github.com/repos/omarkt13/SeaFable_v01/contents/app/api/business/test/route.ts?ref=main\",\n  \"html_url\": \"https://github.com/omarkt13/SeaFable_v01/blob/main/app/api/business/test/route.ts\",\n  \"git_url\": \"https://api.github.com/repos/omarkt13/SeaFable_v01/git/blobs/f0a4576daa280f005d362d03b39c81bbef0a7643\",\n  \"download_url\": \"https://raw.githubusercontent.com/omarkt13/SeaFable_v01/main/app/api/business/test/route.ts\",\n  \"type\": \"file\",\n  \"content\": \"import { NextResponse } from \\\"next/server\\\"\\nimport { createClient } from \\\"@/lib/supabase/server\\\";\\n\\nexport async function GET(request: Request) {\\n  try {\\n    const supabase = createClient();\\n\\n    // Test database connection\\n    const { data, error } = await supabase\\n      .from('business_profiles')\\n      .select('id, business_name')\\n      .limit(1);\\n\\n    if (error) {\\n      return NextResponse.json({ \\n        success: false, \\n        error: error.message \\n      }, { status: 500 });\\n    }\\n\\n    return NextResponse.json({ \\n      success: true, \\n      message: \\\"Business API test successful\\\",\\n      data \\n    });\\n  } catch (error) {\\n    return NextResponse.json({ \\n      success: false, \\n      error: error instanceof Error ? error.message : \\\"Unknown error\\\" \\n    }, { status: 500 });\\n  }\\n}\",\n  \"encoding\": \"base64\",\n  \"_links\": {\n    \"self\": \"https://api.github.com/repos/omarkt13/SeaFable_v01/contents/app/api/business/test/route.ts?ref=main\",\n    \"git\": \"https://api.github.com/repos/omarkt13/SeaFable_v01/git/blobs/f0a4576daa280f005d362d03b39c81bbef0a7643\",\n    \"html\": \"https://github.com/omarkt13/SeaFable_v01/blob/main/app/api/business/test/route.ts\"\n  }\n}", "uuid": "c15c256f-f1e0-44c9-9c25-9174de515952"}]üîç Found the Problem!
I've identified the exact files that are referencing the old table names:
Files with Wrong Table References:

lib/database.ts - Line 833: References business_profiles (should be host_profiles)
app/api/business/test/route.ts - Line 10: References business_profiles (should be host_profiles)

Fix the Database.ts File: